
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>nfs-gaze: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">nfs-gaze/main_unsupported.go (0.0%)</option>
				
				<option value="file1">nfs-gaze/stats_nolinux.go (76.6%)</option>
				
				<option value="file2">nfs-gaze/utils_nolinux.go (49.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">//go:build !linux

package main

import (
        "fmt"
        "os"
)

func main() <span class="cov0" title="0">{
        fmt.Println("This tool is only supported on Linux.")
        os.Exit(1)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">//go:build !linux

package main

import (
        "bufio"
        "fmt"
        "io"
        "os"
        "strconv"
        "strings"
        "time"
)

// parseEvents parses the events line into an NFSEvents struct.
func parseEvents(parts []string) (*NFSEvents, error) <span class="cov8" title="1">{
        if len(parts) &lt; 27 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid number of parts for events: %d", len(parts))
        }</span>

        <span class="cov8" title="1">parseInt := func(s string) (int64, error) </span><span class="cov8" title="1">{
                return strconv.ParseInt(s, 10, 64)
        }</span>

        <span class="cov8" title="1">var (
                err error
                e   NFSEvents
        )

        if e.InodeRevalidate, err = parseInt(parts[0]); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("error parsing InodeRevalidate: %w", err)
        }</span>
        <span class="cov8" title="1">if e.DentryRevalidate, err = parseInt(parts[1]); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing DentryRevalidate: %w", err)
        }</span>
        <span class="cov8" title="1">if e.DataInvalidate, err = parseInt(parts[2]); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing DataInvalidate: %w", err)
        }</span>
        <span class="cov8" title="1">if e.AttrInvalidate, err = parseInt(parts[3]); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing AttrInvalidate: %w", err)
        }</span>
        <span class="cov8" title="1">if e.VFSOpen, err = parseInt(parts[4]); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing VFSOpen: %w", err)
        }</span>
        <span class="cov8" title="1">if e.VFSLookup, err = parseInt(parts[5]); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing VFSLookup: %w", err)
        }</span>
        <span class="cov8" title="1">if e.VFSAccess, err = parseInt(parts[6]); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing VFSAccess: %w", err)
        }</span>
        <span class="cov8" title="1">if e.VFSUpdatePage, err = parseInt(parts[7]); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing VFSUpdatePage: %w", err)
        }</span>
        <span class="cov8" title="1">if e.VFSReadPage, err = parseInt(parts[8]); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing VFSReadPage: %w", err)
        }</span>
        <span class="cov8" title="1">if e.VFSReadPages, err = parseInt(parts[9]); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing VFSReadPages: %w", err)
        }</span>
        <span class="cov8" title="1">if e.VFSWritePage, err = parseInt(parts[10]); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing VFSWritePage: %w", err)
        }</span>
        <span class="cov8" title="1">if e.VFSWritePages, err = parseInt(parts[11]); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing VFSWritePages: %w", err)
        }</span>
        <span class="cov8" title="1">if e.VFSGetdents, err = parseInt(parts[12]); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing VFSGetdents: %w", err)
        }</span>
        <span class="cov8" title="1">if e.VFSSetattr, err = parseInt(parts[13]); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing VFSSetattr: %w", err)
        }</span>
        <span class="cov8" title="1">if e.VFSFlush, err = parseInt(parts[14]); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing VFSFlush: %w", err)
        }</span>
        <span class="cov8" title="1">if e.VFSFsync, err = parseInt(parts[15]); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing VFSFsync: %w", err)
        }</span>
        <span class="cov8" title="1">if e.VFSLock, err = parseInt(parts[16]); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing VFSLock: %w", err)
        }</span>
        <span class="cov8" title="1">if e.VFSRelease, err = parseInt(parts[17]); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing VFSRelease: %w", err)
        }</span>
        <span class="cov8" title="1">if e.CongestionWait, err = parseInt(parts[18]); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing CongestionWait: %w", err)
        }</span>
        <span class="cov8" title="1">if e.SetattrTrunc, err = parseInt(parts[19]); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing SetattrTrunc: %w", err)
        }</span>
        <span class="cov8" title="1">if e.ExtendWrite, err = parseInt(parts[20]); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing ExtendWrite: %w", err)
        }</span>
        <span class="cov8" title="1">if e.SillyRename, err = parseInt(parts[21]); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing SillyRename: %w", err)
        }</span>
        <span class="cov8" title="1">if e.ShortRead, err = parseInt(parts[22]); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing ShortRead: %w", err)
        }</span>
        <span class="cov8" title="1">if e.ShortWrite, err = parseInt(parts[23]); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing ShortWrite: %w", err)
        }</span>
        <span class="cov8" title="1">if e.Delay, err = parseInt(parts[24]); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing Delay: %w", err)
        }</span>
        <span class="cov8" title="1">if len(parts) &gt; 25 </span><span class="cov8" title="1">{
                if e.PNFSRead, err = parseInt(parts[25]); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error parsing PNFSRead: %w", err)
                }</span>
        }
        <span class="cov8" title="1">if len(parts) &gt; 26 </span><span class="cov8" title="1">{
                if e.PNFSWrite, err = parseInt(parts[26]); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error parsing PNFSWrite: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return &amp;e, nil</span>
}

func parseNFSOperation(opName string, stats []string) (*NFSOperation, error) <span class="cov8" title="1">{
        if len(stats) &lt; 9 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid number of stats for op %s: %d", opName, len(stats))
        }</span>

        <span class="cov8" title="1">parseInt := func(s string) (int64, error) </span><span class="cov8" title="1">{
                return strconv.ParseInt(s, 10, 64)
        }</span>

        <span class="cov8" title="1">var (
                err error
                op  NFSOperation
        )

        op.Name = opName
        if op.Ops, err = parseInt(stats[0]); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing ops for %s: %w", opName, err)
        }</span>
        <span class="cov8" title="1">if op.Ntrans, err = parseInt(stats[1]); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing ntrans for %s: %w", opName, err)
        }</span>
        <span class="cov8" title="1">if op.Timeouts, err = parseInt(stats[2]); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing timeouts for %s: %w", opName, err)
        }</span>
        <span class="cov8" title="1">if op.BytesSent, err = parseInt(stats[3]); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing bytes sent for %s: %w", opName, err)
        }</span>
        <span class="cov8" title="1">if op.BytesRecv, err = parseInt(stats[4]); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing bytes recv for %s: %w", opName, err)
        }</span>
        <span class="cov8" title="1">if op.QueueTime, err = parseInt(stats[5]); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing queue time for %s: %w", opName, err)
        }</span>
        <span class="cov8" title="1">if op.RTT, err = parseInt(stats[6]); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing rtt for %s: %w", opName, err)
        }</span>
        <span class="cov8" title="1">if op.ExecuteTime, err = parseInt(stats[7]); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing execute time for %s: %w", opName, err)
        }</span>
        <span class="cov8" title="1">if len(stats) &gt; 8 </span><span class="cov8" title="1">{
                if op.Errors, err = parseInt(stats[8]); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error parsing errors for %s: %w", opName, err)
                }</span>
        }

        <span class="cov8" title="1">return &amp;op, nil</span>
}

type mountstatsParser struct {
        scanner      *bufio.Scanner
        mounts       map[string]*NFSMount
        currentMount *NFSMount
}

func (p *mountstatsParser) parse() error <span class="cov8" title="1">{
        for p.scanner.Scan() </span><span class="cov8" title="1">{
                if err := p.parseLine(p.scanner.Text()); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return p.scanner.Err()</span>
}

func (p *mountstatsParser) parseLine(line string) error <span class="cov8" title="1">{
        line = strings.TrimSpace(line)
        if strings.HasPrefix(line, "device") &amp;&amp; strings.Contains(line, "nfs") </span><span class="cov8" title="1">{
                return p.parseDeviceLine(line)
        }</span> else<span class="cov8" title="1"> if p.currentMount != nil </span><span class="cov8" title="1">{
                return p.parseStatsLine(line)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (p *mountstatsParser) parseDeviceLine(line string) error <span class="cov8" title="1">{
        lineParts := strings.SplitN(line, " on ", 2)
        if len(lineParts) != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid device line: %s", line)
        }</span>
        <span class="cov8" title="1">deviceInfo := strings.Fields(lineParts[0])
        mountInfo := strings.Fields(lineParts[1])

        if len(deviceInfo) &lt; 2 || len(mountInfo) &lt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid device info: %s", line)
        }</span>

        <span class="cov8" title="1">serverExport := deviceInfo[1]
        mountPoint := mountInfo[0]

        serverParts := strings.SplitN(serverExport, ":", 2)
        server := serverParts[0]
        export := "/"
        if len(serverParts) &gt; 1 </span><span class="cov8" title="1">{
                export = serverParts[1]
        }</span>

        <span class="cov8" title="1">p.currentMount = &amp;NFSMount{
                Device:     serverExport,
                MountPoint: mountPoint,
                Server:     server,
                Export:     export,
                Operations: make(map[string]*NFSOperation),
                Events:     &amp;NFSEvents{},
        }
        p.mounts[mountPoint] = p.currentMount
        return nil</span>
}

func (p *mountstatsParser) parseStatsLine(line string) error <span class="cov8" title="1">{
        switch </span>{
        case strings.HasPrefix(line, "age:"):<span class="cov8" title="1">
                return p.parseAge(line)</span>
        case strings.HasPrefix(line, "events:"):<span class="cov8" title="1">
                return p.parseEvents(line)</span>
        case strings.HasPrefix(line, "bytes:"):<span class="cov8" title="1">
                return p.parseBytes(line)</span>
        case strings.Contains(line, ":") &amp;&amp; !strings.HasPrefix(line, "RPC") &amp;&amp;
                !strings.HasPrefix(line, "xprt") &amp;&amp; !strings.HasPrefix(line, "per-op") &amp;&amp;
                !strings.HasPrefix(line, "opts") &amp;&amp; !strings.HasPrefix(line, "caps") &amp;&amp;
                !strings.HasPrefix(line, "sec") &amp;&amp; !strings.HasPrefix(line, "nfsv4") &amp;&amp;
                !strings.HasPrefix(line, "nfsv3"):<span class="cov8" title="1">
                return p.parseOperation(line)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (p *mountstatsParser) parseAge(line string) error <span class="cov8" title="1">{
        parts := strings.Fields(line)
        if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid age line: %s", line)
        }</span>
        <span class="cov8" title="1">var err error
        p.currentMount.Age, err = strconv.ParseInt(parts[1], 10, 64)
        return err</span>
}

func (p *mountstatsParser) parseEvents(line string) error <span class="cov8" title="1">{
        parts := strings.Fields(line)
        if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid events line: %s", line)
        }</span>
        <span class="cov8" title="1">var err error
        p.currentMount.Events, err = parseEvents(parts[1:])
        return err</span>
}

func (p *mountstatsParser) parseBytes(line string) error <span class="cov8" title="1">{
        parts := strings.Fields(line)
        if len(parts) &lt; 6 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid bytes line: %s", line)
        }</span>
        <span class="cov8" title="1">var err error
        p.currentMount.BytesRead, err = strconv.ParseInt(parts[1], 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">p.currentMount.BytesWrite, err = strconv.ParseInt(parts[5], 10, 64)
        return err</span>
}

func (p *mountstatsParser) parseOperation(line string) error <span class="cov8" title="1">{
        opParts := strings.SplitN(line, ":", 2)
        if len(opParts) != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid operation line: %s", line)
        }</span>
        <span class="cov8" title="1">opName := strings.TrimSpace(opParts[0])
        stats := strings.Fields(opParts[1])

        op, err := parseNFSOperation(opName, stats)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">p.currentMount.Operations[opName] = op
        return nil</span>
}

// parseMountstats parses /proc/self/mountstats and returns NFS mount information.
func parseMountstats(path string) (map[string]*NFSMount, error) <span class="cov0" title="0">{
        file, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        return parseMountstatsReader(file)</span>
}

// parseMountstatsReader parses mountstats from an io.Reader for better testability
func parseMountstatsReader(r io.Reader) (map[string]*NFSMount, error) <span class="cov8" title="1">{
        parser := &amp;mountstatsParser{
                scanner: bufio.NewScanner(r),
                mounts:  make(map[string]*NFSMount),
        }

        if err := parser.parse(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return parser.mounts, nil</span>
}


// calculateDelta computes the difference between two measurements.
func calculateDelta(previousOp, currentOp *NFSOperation, durationSec float64) *DeltaStats <span class="cov8" title="1">{
        if previousOp == nil || currentOp == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">deltaOps := currentOp.Ops - previousOp.Ops
        if deltaOps &lt;= 0 </span><span class="cov8" title="1">{
                return &amp;DeltaStats{
                        Operation: currentOp.Name,
                        DeltaOps:  0,
                }
        }</span>

        <span class="cov8" title="1">delta := &amp;DeltaStats{
                Operation:    currentOp.Name,
                DeltaOps:     deltaOps,
                DeltaSent:    currentOp.BytesSent - previousOp.BytesSent,
                DeltaRecv:    currentOp.BytesRecv - previousOp.BytesRecv,
                DeltaBytes:   (currentOp.BytesSent - previousOp.BytesSent) + (currentOp.BytesRecv - previousOp.BytesRecv),
                DeltaRTT:     currentOp.RTT - previousOp.RTT,
                DeltaExec:    currentOp.ExecuteTime - previousOp.ExecuteTime,
                DeltaQueue:   currentOp.QueueTime - previousOp.QueueTime,
                DeltaErrors:  currentOp.Errors - previousOp.Errors,
                DeltaRetrans: currentOp.Timeouts - previousOp.Timeouts,
                IOPS:         float64(deltaOps) / durationSec,
        }

        // Calculate averages
        delta.AvgRTT = float64(delta.DeltaRTT) / float64(deltaOps)
        delta.AvgExec = float64(delta.DeltaExec) / float64(deltaOps)
        delta.AvgQueue = float64(delta.DeltaQueue) / float64(deltaOps)
        delta.KBPerOp = float64(delta.DeltaBytes) / float64(deltaOps) / 1024
        delta.KBPerSec = float64(delta.DeltaBytes) / durationSec / 1024

        return delta</span>
}

// displayStatsNfsiostat shows stats in nfsiostat format.
func displayStatsNfsiostat(mount *NFSMount, stats []*DeltaStats, previousMount *NFSMount, showAttr bool) <span class="cov8" title="1">{
        // Calculate total ops/s
        totalOps := float64(0)
        for _, s := range stats </span><span class="cov8" title="1">{
                if s != nil </span><span class="cov8" title="1">{
                        totalOps += s.IOPS
                }</span>
        }

        // Print mount header and summary
        <span class="cov8" title="1">fmt.Printf("\n%s mounted on %s:\n\n", mount.Device, mount.MountPoint)
        fmt.Printf("%16s %16s\n", "ops/s", "rpc bklog")
        fmt.Printf("%16.3f %16.3f\n\n", totalOps, 0.000)

        // Print per-operation statistics
        for _, s := range stats </span><span class="cov8" title="1">{
                if s == nil || s.DeltaOps == 0 </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">opName := strings.ToLower(s.Operation)
                fmt.Printf("%s:", opName)

                // Calculate error and retrans percentages
                errorPct := float64(0)
                if s.DeltaOps &gt; 0 </span><span class="cov8" title="1">{
                        errorPct = float64(s.DeltaErrors) / float64(s.DeltaOps) * 100
                }</span>
                <span class="cov8" title="1">retransPct := float64(0)
                if s.DeltaOps &gt; 0 </span><span class="cov8" title="1">{
                        retransPct = float64(s.DeltaRetrans) / float64(s.DeltaOps) * 100
                }</span>

                // Print header for this operation
                <span class="cov8" title="1">fmt.Printf("%16s %16s %16s %16s %16s %16s %16s %16s\n",
                        "ops/s", "kB/s", "kB/op", "retrans", "avg RTT (ms)", "avg exe (ms)", "avg queue (ms)", "errors")

                // Print values
                fmt.Printf("%26.3f %16.3f %16.3f %8d (%.1f%%) %16.3f %16.3f %16.3f %8d (%.1f%%)\n",
                        s.IOPS, s.KBPerSec, s.KBPerOp, s.DeltaRetrans, retransPct,
                        s.AvgRTT, s.AvgExec, s.AvgQueue, s.DeltaErrors, errorPct)</span>
        }

        // Print attribute cache statistics if requested
        <span class="cov8" title="1">if showAttr &amp;&amp; previousMount != nil </span><span class="cov8" title="1">{
                fmt.Printf("\n")
                vfsOpens := mount.Events.VFSOpen - previousMount.Events.VFSOpen
                inodeRevals := mount.Events.InodeRevalidate - previousMount.Events.InodeRevalidate
                pageInvals := mount.Events.DataInvalidate - previousMount.Events.DataInvalidate
                attrInvals := mount.Events.AttrInvalidate - previousMount.Events.AttrInvalidate

                fmt.Printf("%d VFS opens\n", vfsOpens)
                fmt.Printf("%d inoderevalidates (forced GETATTRs)\n", inodeRevals)
                fmt.Printf("%d page cache invalidations\n", pageInvals)
                fmt.Printf("%d attribute cache invalidations\n", attrInvals)
        }</span>
}

// displayStatsSimple shows stats in simple format with optional bandwidth.
func displayStatsSimple(mount *NFSMount, stats []*DeltaStats, showBandwidth bool, timestamp time.Time) <span class="cov8" title="1">{
        if len(stats) == 0 </span><span class="cov8" title="1">{
                return
        }</span>

        // Print timestamp and mount point header
        <span class="cov8" title="1">fmt.Printf("\n%s mounted on %s:\n", mount.Device, timestamp.Format("01/02/2006 03:04:05 PM"))

        if showBandwidth </span><span class="cov8" title="1">{
                fmt.Printf("\n%-15s %10s %10s %10s %10s %10s\n",
                        "Operation", "IOPS", "Avg RTT(ms)", "Avg Exec(ms)", "MB/s", "KB/op")
                fmt.Println(strings.Repeat("-", 75))
        }</span> else<span class="cov8" title="1"> {
                fmt.Printf("\n%-15s %10s %10s %10s\n",
                        "Operation", "IOPS", "Avg RTT(ms)", "Avg Exec(ms)")
                fmt.Println(strings.Repeat("-", 52))
        }</span>

        // Print stats for each operation
        <span class="cov8" title="1">for _, s := range stats </span><span class="cov8" title="1">{
                if s == nil || s.DeltaOps == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">if showBandwidth </span><span class="cov8" title="1">{
                        mbPerSec := s.KBPerSec / 1024
                        fmt.Printf("% -15s %10.1f %10.3f %10.3f %10.3f %10.2f\n",
                                s.Operation, s.IOPS, s.AvgRTT, s.AvgExec, mbPerSec, s.KBPerOp)
                }</span> else<span class="cov8" title="1"> {
                        fmt.Printf("% -15s %10.1f %10.3f %10.3f\n",
                                s.Operation, s.IOPS, s.AvgRTT, s.AvgExec)
                }</span>
        }
}</pre>
		
		<pre class="file" id="file2" style="display: none">//go:build !linux

package main

import (
        "flag"
        "fmt"
        "log"
        "os"
        "strconv"
        "strings"
        "time"
)

type Flags struct {
        MountPoint     string
        Operations     string
        Interval       time.Duration
        Count          int
        ShowAttr       bool
        ShowBandwidth  bool
        NfsiostatMode  bool
        ClearScreen    bool
        MountstatsPath string
}

// initFlags initializes and parses the command-line flags.
func initFlags() *Flags <span class="cov8" title="1">{
        flags := &amp;Flags{}

        flag.StringVar(&amp;flags.MountPoint, "m", "", "Mount point to monitor")
        flag.StringVar(&amp;flags.Operations, "ops", "", "Comma-separated list of operations to monitor")
        flag.DurationVar(&amp;flags.Interval, "i", 1*time.Second, "Update interval")
        flag.IntVar(&amp;flags.Count, "c", 0, "Number of iterations (0 = infinite)")
        flag.BoolVar(&amp;flags.ShowAttr, "attr", false, "Show attribute cache statistics")
        flag.BoolVar(&amp;flags.ShowBandwidth, "bw", false, "Show bandwidth statistics")
        flag.BoolVar(&amp;flags.NfsiostatMode, "nfsiostat", false, "Use nfsiostat output format")
        flag.BoolVar(&amp;flags.ClearScreen, "clear", false, "Clear screen between iterations")
        flag.StringVar(&amp;flags.MountstatsPath, "f", "/proc/self/mountstats", "Path to mountstats file")

        flag.Usage = func() </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "NFS I/O Statistics Monitor\n\n")
                fmt.Fprintf(os.Stderr, "Usage: %s [options] [mount_point] [interval] [count]\n\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "Options:\n")
                flag.PrintDefaults()
                fmt.Fprintf(os.Stderr, "\nExamples:\n")
                fmt.Fprintf(os.Stderr, "  # Monitor in nfsiostat format\n")
                fmt.Fprintf(os.Stderr, "  %s --nfsiostat /mnt/nfs --attr\n\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "  # Monitor specific operations with bandwidth\n")
                fmt.Fprintf(os.Stderr, "  %s -m /mnt/nfs -ops READ,WRITE -bw\n\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "  # Clear screen between iterations\n")
                fmt.Fprintf(os.Stderr, "  %s -m /mnt/nfs --clear\n\n", os.Args[0])
        }</span>

        <span class="cov8" title="1">flag.Parse()

        args := flag.Args()
        if len(args) &gt; 0 &amp;&amp; flags.MountPoint == "" </span><span class="cov8" title="1">{
                flags.MountPoint = args[0]
        }</span>
        <span class="cov8" title="1">if len(args) &gt; 1 </span><span class="cov8" title="1">{
                if intervalSec, err := strconv.Atoi(args[1]); err == nil </span><span class="cov8" title="1">{
                        flags.Interval = time.Duration(intervalSec) * time.Second
                }</span>
        }
        <span class="cov8" title="1">if len(args) &gt; 2 </span><span class="cov8" title="1">{
                if countVal, err := strconv.Atoi(args[2]); err == nil </span><span class="cov8" title="1">{
                        flags.Count = countVal
                }</span>
        }

        <span class="cov8" title="1">return flags</span>
}

// parseOperationsFilter parses the comma-separated list of operations to monitor.
func parseOperationsFilter(operations string) map[string]bool <span class="cov8" title="1">{
        var opsFilter map[string]bool
        if operations != "" </span><span class="cov8" title="1">{
                opsFilter = make(map[string]bool)
                for _, op := range strings.Split(operations, ",") </span><span class="cov8" title="1">{
                        opsFilter[strings.TrimSpace(op)] = true
                }</span>
        }
        <span class="cov8" title="1">return opsFilter</span>
}

// getMountsToMonitor determines which mounts to monitor based on user input.
func getMountsToMonitor(mountPoint string, previousMounts map[string]*NFSMount) ([]string, error) <span class="cov8" title="1">{
        var monitorMounts []string
        if mountPoint != "" </span><span class="cov8" title="1">{
                if _, exists := previousMounts[mountPoint]; !exists </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("mount point %s not found", mountPoint)
                }</span>
                <span class="cov8" title="1">monitorMounts = append(monitorMounts, mountPoint)</span>
        } else<span class="cov8" title="1"> {
                for mp := range previousMounts </span><span class="cov8" title="1">{
                        monitorMounts = append(monitorMounts, mp)
                }</span>
                <span class="cov8" title="1">if len(monitorMounts) == 0 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("no NFS mounts found")
                }</span>
        }
        <span class="cov8" title="1">return monitorMounts, nil</span>
}

// printInitialSummary prints the initial summary of the monitored mounts.
func printInitialSummary(flags *Flags, monitorMounts []string, previousMounts map[string]*NFSMount, opsFilter map[string]bool) <span class="cov8" title="1">{
        if flags.NfsiostatMode </span><span class="cov8" title="1">{
                for _, mp := range monitorMounts </span><span class="cov8" title="1">{
                        mount := previousMounts[mp]
                        if mount == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">var stats []*DeltaStats
                        mountAgeSec := float64(mount.Age)

                        for _, op := range mount.Operations </span><span class="cov8" title="1">{
                                if op.Ops &gt; 0 </span><span class="cov8" title="1">{
                                        // Apply filter if specified
                                        if opsFilter != nil &amp;&amp; !opsFilter[op.Name] </span><span class="cov0" title="0">{
                                                continue</span>
                                        }

                                        <span class="cov8" title="1">delta := &amp;DeltaStats{
                                                Operation:    op.Name,
                                                DeltaOps:     op.Ops,
                                                DeltaSent:    op.BytesSent,
                                                DeltaRecv:    op.BytesRecv,
                                                DeltaBytes:   op.BytesSent + op.BytesRecv,
                                                DeltaRTT:     op.RTT,
                                                DeltaExec:    op.ExecuteTime,
                                                DeltaQueue:   op.QueueTime,
                                                DeltaErrors:  op.Errors,
                                                DeltaRetrans: op.Timeouts,
                                                IOPS:         float64(op.Ops) / mountAgeSec,
                                                AvgRTT:       float64(op.RTT) / float64(op.Ops),
                                                AvgExec:      float64(op.ExecuteTime) / float64(op.Ops),
                                                AvgQueue:     float64(op.QueueTime) / float64(op.Ops),
                                                KBPerOp:      float64(op.BytesSent+op.BytesRecv) / float64(op.Ops) / 1024,
                                                KBPerSec:     float64(op.BytesSent+op.BytesRecv) / mountAgeSec / 1024,
                                        }
                                        stats = append(stats, delta)</span>
                                }
                        }

                        <span class="cov8" title="1">if len(stats) &gt; 0 </span><span class="cov8" title="1">{
                                displayStatsNfsiostat(mount, stats, nil, flags.ShowAttr)
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                // Print header for simple mode
                fmt.Printf("Monitoring NFS mount: %s (%s)\n", monitorMounts[0], previousMounts[monitorMounts[0]].Device)
                fmt.Printf("Update interval: %v\n", flags.Interval)
                if flags.Operations != "" </span><span class="cov8" title="1">{
                        fmt.Printf("Filtering operations: %s\n", flags.Operations)
                }</span>
        }
}

// monitoringLoop is the main monitoring loop of the application.
func monitoringLoop(sigChan chan os.Signal, flags *Flags, monitorMounts []string, previousMounts map[string]*NFSMount, opsFilter map[string]bool) <span class="cov0" title="0">{
        // Monitoring loop
        iteration := 0
        ticker := time.NewTicker(flags.Interval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        iteration++

                        // Read current stats
                        currentMounts, err := parseMountstats(flags.MountstatsPath)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error reading mountstats: %v", err)
                                continue</span>
                        }

                        <span class="cov0" title="0">timestamp := time.Now()
                        duration := flags.Interval.Seconds()

                        // Clear screen if requested (only for simple mode)
                        if flags.ClearScreen &amp;&amp; !flags.NfsiostatMode </span><span class="cov0" title="0">{
                                fmt.Print("\033[H\033[2J")
                                // Reprint header after clearing
                                fmt.Printf("Monitoring NFS mount: %s (%s)\n", monitorMounts[0], currentMounts[monitorMounts[0]].Device)
                                fmt.Printf("Update interval: %v | Time: %s\n", flags.Interval, timestamp.Format("15:04:05"))
                                if flags.Operations != "" </span><span class="cov0" title="0">{
                                        fmt.Printf("Filtering operations: %s\n", flags.Operations)
                                }</span>
                        }

                        // Process each monitored mount
                        <span class="cov0" title="0">for _, mp := range monitorMounts </span><span class="cov0" title="0">{
                                currentMount, exists := currentMounts[mp]
                                if !exists </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                <span class="cov0" title="0">previousMount := previousMounts[mp]
                                if previousMount == nil </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                // Calculate deltas
                                <span class="cov0" title="0">var stats []*DeltaStats

                                for opName, currentOp := range currentMount.Operations </span><span class="cov0" title="0">{
                                        // Apply filter if specified
                                        if opsFilter != nil &amp;&amp; !opsFilter[opName] </span><span class="cov0" title="0">{
                                                continue</span>
                                        }

                                        <span class="cov0" title="0">previousOp := previousMount.Operations[opName]
                                        if previousOp != nil </span><span class="cov0" title="0">{
                                                delta := calculateDelta(previousOp, currentOp, duration)
                                                if delta != nil &amp;&amp; delta.DeltaOps &gt; 0 </span><span class="cov0" title="0">{
                                                        stats = append(stats, delta)
                                                }</span>
                                        }
                                }

                                // Display results
                                <span class="cov0" title="0">if flags.NfsiostatMode </span><span class="cov0" title="0">{
                                        // Always display in nfsiostat mode (even with no activity)
                                        displayStatsNfsiostat(currentMount, stats, previousMount, flags.ShowAttr)
                                }</span> else<span class="cov0" title="0"> if len(stats) &gt; 0 </span><span class="cov0" title="0">{
                                        // Simple mode - only show if there's activity
                                        displayStatsSimple(currentMount, stats, flags.ShowBandwidth, timestamp)
                                }</span>
                        }

                        // Update previous stats
                        <span class="cov0" title="0">previousMounts = currentMounts

                        // Check iteration count
                        if flags.Count &gt; 0 &amp;&amp; iteration &gt;= flags.Count </span><span class="cov0" title="0">{
                                return
                        }</span>

                case &lt;-sigChan:<span class="cov0" title="0">
                        fmt.Println("\nCaught ^C... exiting")
                        return</span>
                }
        }
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
